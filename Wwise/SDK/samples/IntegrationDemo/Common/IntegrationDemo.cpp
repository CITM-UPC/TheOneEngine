/*******************************************************************************
The content of this file includes portions of the AUDIOKINETIC Wwise Technology
released in source code form as part of the SDK installer package.

Commercial License Usage

Licensees holding valid commercial licenses to the AUDIOKINETIC Wwise Technology
may use this file in accordance with the end user license agreement provided 
with the software or, alternatively, in accordance with the terms contained in a
written agreement between you and Audiokinetic Inc.

  Copyright (c) 2023 Audiokinetic Inc.
*******************************************************************************/

// IntegrationDemo.cpp
/// \file 
/// Implements all functions declared in IntegrationDemo.h

#include "stdafx.h"

#include "Render.h"
#include "Drawing.h"
#include "BaseMenuPage.h"
#include "IntegrationDemo.h"
#include "Menu.h"
#include "Platform.h"
#include "Wwise_IDs.h"		// IDs generated by Wwise
#include "AkJobWorkerMgr.h"
#include "PlatformHooks.h"


#include <AK/Plugin/AllPluginsFactories.h>

#define DATA_SUMMARY_REFRESH_COOLDOWN 7; // Refresh cooldown affecting the refresh rate of the resource monitor data summary

using namespace AKPLATFORM;

/////////////////////////////
// IntegrationDemo Members
/////////////////////////////

AkResourceMonitorDataSummary IntegrationDemo::ResourceDataSummary;

IntegrationDemo& IntegrationDemo::Instance()
{
	static IntegrationDemo demo;
	return demo;
}

IntegrationDemo::IntegrationDemo():
m_pInput(NULL),
m_pMenu(NULL),
m_pLowLevelIO(NULL),
m_bGamePaused(false)
{
	m_pMenu = new Menu();
    m_pLowLevelIO = new CAkFilePackageLowLevelIODeferred();

#if defined(AK_ENABLE_FRAME_LIMITATION)
	m_iFrameCounter=-1;
#endif

	GetDefaultSettings();
}

IntegrationDemo::~IntegrationDemo()
{
	delete m_pLowLevelIO;
	m_pLowLevelIO = NULL;
	
	delete m_pMenu;
	m_pMenu = NULL;
	
	m_pInput = NULL;
}

CAkFilePackageLowLevelIODeferred& IntegrationDemo::IOManager()
{
	return *m_pLowLevelIO;
}

bool IntegrationDemo::Init(	
	void* in_pParam,
	IAkInputMgr* in_pInputMgr,
	AkOSChar* in_szErrorBuffer,
	unsigned int in_unErrorBufferCharCount,
	AkUInt32 in_windowWidth,
	AkUInt32 in_windowHeight
)
{	
	BaseMenuPage* basePage = NULL;
	bool bSuccess;
	
	m_pInput = in_pInputMgr;

#if defined (OLD_INTDEMO_RENDER)
	// Initialize the drawing engine
	bSuccess = InitDrawing(in_pParam, in_szErrorBuffer, in_unErrorBufferCharCount, in_windowWidth, in_windowHeight);
	if (!bSuccess)
	{
		goto cleanup;
	}
#else
	// Initialize the drawing engine
	bSuccess = RenderInit(in_pParam, in_szErrorBuffer, in_unErrorBufferCharCount);
	if (!bSuccess)
	{
		goto cleanup;
	}

	// Init drawing - prefer a 1:1 canvas vs. window size, but layout is hard-coded to 1280*720 (16:9) for consistent layout on all platforms
	bSuccess = InitDrawing(in_szErrorBuffer, in_unErrorBufferCharCount, in_windowWidth, in_windowHeight, 1280, 720);
	if (!bSuccess)
	{
		goto cleanup;
	}
#endif

	// Initialize the Input Manager object
	bSuccess = m_pInput->Init( in_szErrorBuffer, in_unErrorBufferCharCount );
	if ( !bSuccess )
	{
		goto cleanup;
	}	

	// Initialize Wwise
	bSuccess = InitWwise( in_szErrorBuffer, in_unErrorBufferCharCount );
	if ( !bSuccess )
	{
		goto cleanup;
	}
	
	// Initialize the Menu System object
	basePage = new BaseMenuPage( *m_pMenu );
	
	m_pMenu->Init(m_pInput->UniversalInputAdapter(),
#if defined (OLD_INTDEMO_RENDER)
					IntegrationDemo::Instance().GetWindowWidth(),
					IntegrationDemo::Instance().GetWindowHeight(),
#else
					IntegrationDemo::Instance().GetLayoutWidth(),
					IntegrationDemo::Instance().GetLayoutHeight(),
		
#endif
					DESIRED_FPS,
					*basePage );


#ifndef AK_OPTIMIZED 
	m_xmlMsgTranslator.SetFileName(AKTEXT("SoundbanksInfo.xml"));
	AK::Monitor::AddTranslator(&m_xmlMsgTranslator);
#endif //AK_OPTIMIZED

	// Initialize the timing variables
	PerformanceFrequency( &m_PerfFreq );

	return true;

cleanup:
	Term();
	return false;
}

void IntegrationDemo::StartFrame()
{
	PerformanceCounter( &m_FrameStartPerf );
}

bool IntegrationDemo::Update()
{
	if (m_bGamePaused)
	{
		return true;
	}
	
	m_pInput->Update();
	return m_pMenu->Update();
}

void IntegrationDemo::OnPointerEvent( PointerEventType in_eType, int in_x, int in_y )
{
	m_pMenu->OnPointerEvent( in_eType, in_x, in_y );
}

void IntegrationDemo::OnBack()
{
	m_pMenu->Back();
}

void IntegrationDemo::Render()
{
	if(m_bGamePaused)
		return;

#if defined(AK_ENABLE_FRAME_LIMITATION)
	// On some platforms our frame rate is higher and it brings video rendering performance issues, Make it skip some frames so it is fluid and more like other platforms
	++m_iFrameCounter;
	if (m_iFrameCounter % 3 == 0)
#endif
	{
#if !defined (OLD_INTDEMO_RENDER)
		RenderBeginFrame();
#endif
		m_pMenu->Draw();

#if !defined (OLD_INTDEMO_RENDER)
		RenderEndFrame();
#endif
	}

	if (AK::SoundEngine::IsInitialized())
	{
#if !defined(AK_SUPPORT_THREADS)
		// In single-threaded environments, process all pending I/O actions prior to rendering audio.
		AK::StreamMgr::PerformIO();
#endif
		AK::SoundEngine::RenderAudio();
	}
}

void IntegrationDemo::EndFrame()
{
#if !defined(AK_EMSCRIPTEN)
	AkInt32 iSleepTime = CalculateSleepTime();
	AkSleep( iSleepTime );
#endif
}

void IntegrationDemo::Term()
{
	AK::SoundEngine::UnregisterResourceMonitorCallback(ResourceMonitorDataCallback);
	TermDrawing();
#if !defined (OLD_INTDEMO_RENDER)
	RenderTerm();
#endif
#ifndef AK_OPTIMIZED 
	m_xmlMsgTranslator.Term();
#endif //AK_OPTIMIZED

	m_pInput->Release();
	m_pMenu->Release();
	// Terminate Wwise
	TermWwise();
}

void IntegrationDemo::GetDefaultSettings()
{
	AK::MemoryMgr::GetDefaultSettings(m_memSettings);
	AK::StreamMgr::GetDefaultSettings(m_stmSettings);
	AK::StreamMgr::GetDefaultDeviceSettings(m_deviceSettings);
	
	AK::SoundEngine::GetDefaultInitSettings(m_initSettings);
#if defined( INTEGRATIONDEMO_ASSERT_HOOK )
	m_initSettings.pfnAssertHook = INTEGRATIONDEMO_ASSERT_HOOK;
#endif // defined( INTEGRATIONDEMO_ASSERT_HOOK )

	// Set bDebugOutOfRangeCheck to true by default. This can help catch some errors, and it's not expensive!
#if !defined(AK_OPTIMIZED)
	m_initSettings.bDebugOutOfRangeCheckEnabled = true;
#endif

	AK::SoundEngine::GetDefaultPlatformInitSettings(m_platformInitSettings);
	AK::MusicEngine::GetDefaultInitSettings(m_musicInit);

	// The default job worker manager provided in the samples will generate more appropriate settings for the internal job manager of the sound engine.
	AK::JobWorkerMgr::GetDefaultInitSettings(m_jobWorkerSettings);
	m_jobWorkerSettings.uNumWorkerThreads = AK_MAX_WORKER_THREADS;
	m_initSettings.settingsJobManager = m_jobWorkerSettings.GetJobMgrSettings();
	for (AkUInt32 uJobType = 0; uJobType < AK_NUM_JOB_TYPES; ++uJobType)
	{
		m_initSettings.settingsJobManager.uMaxActiveWorkers[uJobType] = 2;
	}
	
#if !defined AK_OPTIMIZED && !defined INTEGRATIONDEMO_DISABLECOMM
	AK::Comm::GetDefaultInitSettings(m_commSettings);
#endif
}

bool IntegrationDemo::InitWwise(AkOSChar* in_szErrorBuffer, unsigned int in_unErrorBufferCharCount)
{
	AK::IntegrationDemo::PlatformHooks::Get()->PreInit(this);

    //
    // Create and initialize an instance of the default memory manager. Note
    // that you can override the default memory manager with your own. Refer
    // to the SDK documentation for more information.
    //
	AKRESULT res = AK::MemoryMgr::Init( &m_memSettings );
    if ( res != AK_Success )
    {
		__AK_OSCHAR_SNPRINTF( in_szErrorBuffer, in_unErrorBufferCharCount, AKTEXT("AK::MemoryMgr::Init() returned AKRESULT %d"), res );
        return false;
    }

	//
    // Create and initialize an instance of the default streaming manager. Note
    // that you can override the default streaming manager with your own. Refer
    // to the SDK documentation for more information.
    //

    // Customize the Stream Manager settings here.
    
    if ( !AK::StreamMgr::Create( m_stmSettings ) )
    {
		AKPLATFORM::SafeStrCpy( in_szErrorBuffer, AKTEXT( "AK::StreamMgr::Create() failed" ), in_unErrorBufferCharCount );
        return false;
    }
    
	// 
    // Create a streaming device with blocking low-level I/O handshaking.
    // Note that you can override the default low-level I/O module with your own. Refer
    // to the SDK documentation for more information.        
	//
    
    // CAkFilePackageLowLevelIODeferred::Init() creates a streaming device
    // in the Stream Manager, and registers itself as the File Location Resolver.
	m_deviceSettings.bUseStreamCache = true;
	res = m_pLowLevelIO->Init( m_deviceSettings );
	if ( res != AK_Success )
	{
		__AK_OSCHAR_SNPRINTF( in_szErrorBuffer, in_unErrorBufferCharCount, AKTEXT("m_lowLevelIO.Init() returned AKRESULT %d"), res );
        return false;
    }

	//
	// Create and start the job worker threads that the Sound Engine will use
	// Using the default sample implementation supplied in the Wwise SDK samples
	//
	if (m_jobWorkerSettings.uNumWorkerThreads > 0)
	{
		res = AK::JobWorkerMgr::InitWorkers(m_jobWorkerSettings);
		if (res != AK_Success)
		{
			__AK_OSCHAR_SNPRINTF(in_szErrorBuffer, in_unErrorBufferCharCount, AKTEXT("AK::JobWorkerMgr::InitWorkers() returned AKRESULT %d"), res);
			return false;
		}
	}

    //
    // Create the Sound Engine
    // Using default initialization parameters
    //
	res = AK::SoundEngine::Init( &m_initSettings, &m_platformInitSettings );
    if ( res != AK_Success )
    {
		__AK_OSCHAR_SNPRINTF( in_szErrorBuffer, in_unErrorBufferCharCount, AKTEXT("AK::SoundEngine::Init() returned AKRESULT %d"), res );
        return false;
    }

    //
    // Initialize the music engine
    // Using default initialization parameters
    //

	res = AK::MusicEngine::Init( &m_musicInit );
    if ( res != AK_Success )
    {
		__AK_OSCHAR_SNPRINTF( in_szErrorBuffer, in_unErrorBufferCharCount, AKTEXT("AK::MusicEngine::Init() returned AKRESULT %d"), res );
        return false;
    }

#if !defined AK_OPTIMIZED && !defined INTEGRATIONDEMO_DISABLECOMM
    //
    // Initialize communications (not in release build!)
    //
	AKPLATFORM::SafeStrCpy(m_commSettings.szAppNetworkName, "Integration Demo", AK_COMM_SETTINGS_MAX_STRING_SIZE);

	res = AK::Comm::Init(m_commSettings);
	if ( res != AK_Success )
	{
		__AK_OSCHAR_SNPRINTF( in_szErrorBuffer, in_unErrorBufferCharCount, AKTEXT("AK::Comm::Init() returned AKRESULT %d. Communication between the Wwise authoring application and the game will not be possible."), res );
	}
#endif // AK_OPTIMIZED	
   
	AkSpatialAudioInitSettings settings;
	
	res = AK::SpatialAudio::Init(settings);
	if (res != AK_Success)
	{
		__AK_OSCHAR_SNPRINTF(in_szErrorBuffer, in_unErrorBufferCharCount, AKTEXT("AK::SpatialAudio::Init() returned AKRESULT %d"), res);
		return false;
	}

	AK::SoundEngine::RegisterGameObj(LISTENER_ID, "Listener (Default)");
	AK::SoundEngine::SetDefaultListeners(&LISTENER_ID, 1);
		
	// For platforms with a read-only bank path, add a writable folder
	// to the list of base paths. IO will fallback on this path
	// when opening a file for writing fails.
#if defined(WRITABLE_PATH)
	m_pLowLevelIO->AddBasePath(WRITABLE_PATH);
#endif

	// Set the path to the SoundBank Files last.
	// The last base path is always the first queried for files.
	m_pLowLevelIO->SetBasePath(SOUND_BANK_PATH);

	// Set global language. Low-level I/O devices can use this string to find language-specific assets.
	if (AK::StreamMgr::SetCurrentLanguage(AKTEXT("English(US)")) != AK_Success)	
		return false;	

	AK::SoundEngine::RegisterResourceMonitorCallback(ResourceMonitorDataCallback);

	AK::Monitor::SetLocalOutput(AK::Monitor::ErrorLevel_All, LocalErrorCallback);
	
    return true;
}

void IntegrationDemo::TermWwise()
{
#if !defined AK_OPTIMIZED && !defined INTEGRATIONDEMO_DISABLECOMM
	// Terminate communications between Wwise and the game
	AK::Comm::Term();
#endif // AK_OPTIMIZED
	// Terminate the music engine
	AK::MusicEngine::Term();

	// Terminate the sound engine
	if ( AK::SoundEngine::IsInitialized() )
	{
		AK::SoundEngine::Term();
	}

	// Stop and clean up the worker threads
	if (m_jobWorkerSettings.uNumWorkerThreads > 0)
	{
		AK::JobWorkerMgr::TermWorkers();
	}

#ifndef AK_OPTIMIZED 
	m_xmlMsgTranslator.Term();
#endif //AK_OPTIMIZED 

	// Terminate the streaming device and streaming manager
	// CAkFilePackageLowLevelIODeferred::Term() destroys its associated streaming device 
	// that lives in the Stream Manager, and unregisters itself as the File Location Resolver.
    if ( AK::IAkStreamMgr::Get() )
	{
		m_pLowLevelIO->Term();
		AK::IAkStreamMgr::Get()->Destroy();
	}

	// Terminate the Memory Manager
	if ( AK::MemoryMgr::IsInitialized() )
	{
		AK::MemoryMgr::Term();
	}
}

AkInt32 IntegrationDemo::CalculateSleepTime()
{
	AkInt64  iFrameEndPerf;	  // Performance counter at the end of the current frame
	PerformanceCounter( &iFrameEndPerf );

	// Calculate how long the current frame has lasted so far
	AkReal64 dblCurrFrameDur = ( (AkReal64)( iFrameEndPerf - m_FrameStartPerf ) * 1000 / (AkReal64)m_PerfFreq );

	// We want sleep the remainder to get to a duration of MS_PER_FRAME
	AkInt32 iSleepTime = AkMax( 0, (AkInt32)(MS_PER_FRAME - dblCurrFrameDur));
	return iSleepTime;	 
}

void IntegrationDemo::LocalErrorCallback(AK::Monitor::ErrorCode in_eErrorCode, const AkOSChar* in_pszError, AK::Monitor::ErrorLevel in_eErrorLevel, AkPlayingID in_playingID, AkGameObjectID in_gameObjID)
{
	char* pszErrorStr;
	CONVERT_OSCHAR_TO_CHAR(in_pszError, pszErrorStr);

	if (in_eErrorLevel == AK::Monitor::ErrorLevel_Error)
	{
		// Error handle Plugin Errors to be shown in plugin context.
		if (in_eErrorCode == AK::Monitor::ErrorCode_PluginFileNotFound || in_eErrorCode == AK::Monitor::ErrorCode_PluginNotRegistered || in_eErrorCode == AK::Monitor::ErrorCode_PluginFileRegisterFailed)
		{
			Instance().m_pMenu->SetPluginLog(pszErrorStr);
		}
		else
		{
			Page * pPage = Instance().m_pMenu->GetCurrentPage();
			if (pPage != nullptr)
			{
				Instance().m_pMenu->GetCurrentPage()->SetErrorMessage(pszErrorStr);
			}
		}
	}
	AKPLATFORM::OutputDebugMsgV("%s: %s\n", in_eErrorLevel == AK::Monitor::ErrorLevel_Message ? "AK Message" : "AK Error", pszErrorStr);
}

static bool s_bWasIntegrationDemoPausedOnce = false;// Prevent a void attempt to resume when we never paused.

void IntegrationDemo::Mute()
{
	if (AK::SoundEngine::IsInitialized())
	{
		AK::SoundEngine::PostEvent(AK::EVENTS::PAUSE_ALL_GLOBAL, AK_INVALID_GAME_OBJECT);
		AK::SoundEngine::RenderAudio();
	}
}

void IntegrationDemo::Unmute()
{
	if (AK::SoundEngine::IsInitialized())
	{
		AK::SoundEngine::PostEvent(AK::EVENTS::RESUME_ALL_GLOBAL, AK_INVALID_GAME_OBJECT);
		AK::SoundEngine::RenderAudio();
	}
}

void IntegrationDemo::Pause()
{
	if ( AK::SoundEngine::IsInitialized() )
	{
		s_bWasIntegrationDemoPausedOnce = true;
		AK::SoundEngine::PostEvent(AK::EVENTS::PAUSE_ALL_GLOBAL, AK_INVALID_GAME_OBJECT);
		AK::SoundEngine::RenderAudio();

		AK::SoundEngine::Suspend(false);
		IntegrationDemo::Instance().SetGamePaused(true);
	}
}

void IntegrationDemo::Resume()
{
	if (AK::SoundEngine::IsInitialized() && s_bWasIntegrationDemoPausedOnce)
	{
		AK::SoundEngine::WakeupFromSuspend();
		AK::SoundEngine::PostEvent(AK::EVENTS::RESUME_ALL_GLOBAL, AK_INVALID_GAME_OBJECT);
		AK::SoundEngine::RenderAudio();
		
		IntegrationDemo::Instance().SetGamePaused(false);
	}
}

AkUInt32 IntegrationDemo::GetDefaultAudioDeviceSharesetId()
{
	// Because we init the SoundEngine with AkInputSettings::settingsMainOutput::audioDeviceShareset
	// set to its default (i.e. 0), the Audio Device Shareset used is the one linked with the Master
	// Audio Bus in the Wwise project. 
	const static AkUInt32 defaultSharesetId = AK::SoundEngine::GetIDFromString("System");
	return defaultSharesetId;
}

const std::vector<const char*> IntegrationDemo::GetSupportedAudioDeviceSharesets()
{
	static std::vector<const char*> supportedSharesets;
	
	if (supportedSharesets.empty())
	{
		supportedSharesets.push_back("System");
#if defined(AK_PS4)
		supportedSharesets.push_back("Pad_Output");
#elif defined(AK_XBOX)
		// Xbox supports the following sharesets but can use and will list the same devices for all of them.
		// So only keep the System sink to prevent redundancy.
		//supportedSharesets.push_back("Controller_Headphones");
		//supportedSharesets.push_back("DVR_Bypass");
#endif
	}

	return supportedSharesets;
}

AkUInt32 IntegrationDemo::GetSpatialAudioSharesetId()
{
	// When we want to enable the platform-specific spatial audio engine, we do so by specifying a
	// device shareset Id. This can be seen in (or added to) your Wwise Project's list of Audio Devices,
	// in the ShareSets tab of the Project Explorer
#if defined(AK_WIN) || defined(AK_XBOX)
	const static AkUInt32 spatialSharesetId = AK::SoundEngine::GetIDFromString("Microsoft_Spatial_Sound_Platform_Output");
#elif defined(AK_SONY)
	const static AkUInt32 spatialSharesetId = AK::SoundEngine::GetIDFromString("SCE_Audio3d_Bed_Output");
#else
	const static AkUInt32 spatialSharesetId = 0;
#endif
	return spatialSharesetId;
}

AkUInt32 IntegrationDemo::GetDefaultAudioDeviceId()
{
	// Because we init the SoundEngine with AkInputSettings::settingsMainOutput::idDevice
	// set to its default (i.e. 0) the SoundEngine will have used this value to create the
	// primary output device.
	return 0;
}

void IntegrationDemo::ResourceMonitorDataCallback(const AkResourceMonitorDataSummary * in_pdataSummary)
{
	static int ResourceMonitorUpdateCooldown = 0;
	if (ResourceMonitorUpdateCooldown <= 0)
	{
		IntegrationDemo::ResourceDataSummary = *in_pdataSummary;
		ResourceMonitorUpdateCooldown = DATA_SUMMARY_REFRESH_COOLDOWN;
	}
	else
		ResourceMonitorUpdateCooldown--;
}
